apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: github-entrypoint-task
spec:
  params:
    - name: gitHubEvent
      description: GitHub event
      type: string

    - name: gitHubPayload
      description: GitHub payload from Webhook
      type: string

    - name: gitHubRequestUrl
      description: GitHub request url
      type: string

    - name: gitHubFilePayload
      description: GitHub payload file
      type: string
      default: github-payload.conf

    #- name: gitHubFileWebhookParams
    #  description: GitHub payload file
    #  type: string
    #  default: github-webhook-params.conf

  workspaces:
    - name: github

  steps:
    # Create a file with the GitHub payload
    # Note: This task create a file with a new payload adding the GitHub event and query string 
    #       parameters from webhook
    - name: create-github-payload
      image: quay.io/jberchez-redhat/custom-utils:v1.0
      script: |
        #! /usr/bin/env python3

        from urllib.parse import parse_qs

        import urllib.parse as urlparse
        import requests
        import json
        import os
        import sys
        import yaml
        import re

        #token = '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'
        token              = os.environ.get('GITHUB_TOKEN')
        headers            = {"Authorization": "token {}".format(token)}
        file_payload       = "$(workspaces.github.path)/$(params.gitHubFilePayload)"
        payload_str        = "{}".format('$(params.gitHubPayload)')
        github_request_url = "{}".format('$(params.gitHubRequestUrl)')
        payload            = {}
        hook               = ""
        params             = []

        # Data from webhook request url
        custom_data  = {}

        if token == None:
           print("[ERROR] Unable to find GitHub token")
           sys.exit(1)

        if len(payload_str) == 0:
          print("[ERROR]: GitHub payload empty")
          sys.exit(1)

        payload = json.loads(payload_str)

        if not 'repository' in payload:
           print("[ERROR] Unable to find 'repository' in payload")
           sys.exit(1)

        if not 'hooks_url' in payload['repository']:
           print("[ERROR] Unable to find 'hooks_url' in payload")
           sys.exit(1)

        hooks_url = "{}".format(payload['repository']['hooks_url'])

        try:
           r    = requests.get(hooks_url, headers=headers)
           data = json.loads(r.content.decode("UTF-8"))

           github_request_url = re.sub(r':$', "", github_request_url)

           for h in data:
              if 'config' in h and 'url' in h['config']:
                 if h['config']['url'].startswith(github_request_url):
                    hook = "{}".format(h['config']['url'])
                    break
        except Exception as e:
           print("[ERROR] {}".format(e))
           sys.exit(1)

        if len(hook) == 0:
           print("[ERROR] WebHook not found")
           sys.exit(1)

        # Extract params from webhook
        parsed = urlparse.urlparse(hook)
        p      = parsed.query.split('&')

        for i in p:
           i = i.replace(" ", "")
           d = i.split("=")

           key = "{}".format(d[0])
           val = "{}".format(d[1])

           if len(key) == 0:
             print("[ERROR] Unable to find a key in webhook URL parameters")
             sys.exit(1)
           elif len(val) == 0:
             print("[ERROR] Unable to find a value in key \"{}\" in webhook URL parameters".format(key))
             sys.exit(1)

           key = key.upper()
           val = val.lower()

           custom_data[key] = val

        if len(custom_data) == 0:
           print("[ERROR] Unable to find data in webhook URL parameters")
           sys.exit(1)

        # Check if "TYPE" key exists
        # Note: TYPE is the key to know the pipeline to run
        if not 'TYPE' in custom_data:
          print("[ERROR] Unable to find key 'TYPE' in Webhook URL")
          sys.exit(1)

        # Add custom_data to payload
        payload['custom_data'] = custom_data

        # Add github_event_got key with the github event we got
        payload['github_event_got'] = "{}".format('$(params.gitHubEvent)')

        # Create the file with the new payload
        try:
           f = open(file_payload,"w")
           f.write(json.dumps(payload))
           f.close()
        except Exception as e:
           print("[ERROR] {}".format(e))
           sys.exit(1)

        sys.exit(0)

      env:
        - name: GITHUB_TOKEN
          valueFrom:
            secretKeyRef:
              name: github-webhook-token
              key: githubToken

    - name: run-pipeline
      image: quay.io/jberchez-redhat/custom-utils:v1.0
      script: |
        #! /usr/bin/env python3 

        import sys
        import json
        import subprocess

        file_payload     = "$(workspaces.github.path)/$(params.gitHubFilePayload)"

        # Name pipeline to run
        pipeline         = ""

        # GitHub payload
        payload          = {}

        try:
           f = open(file_payload, "r")
           payload = json.load(f)
           f.close()
        except Exception as e:
           print("[ERROR] {}".format(e))
           sys.exit(1)

        # Check TYPE to run the right pipeline
        if payload['custom_data']['TYPE'] == "microservice":
           pipeline = "pipeline-microservice"
        else:
          print("[ERROR] Unknown TYPE: {}".format(payload['custom_data']['TYPE']))
          sys.exit(1)

        now       = datetime.now()
        date_time = now.strftime("%m-%d-%Y_%H-%M-%S")

        # Create command to run
        cmd = "tkn pipeline start {} --showlog --use-param-defaults --prefix-name {} --param payload=\"{}\"".format(pipeline, date_time, payload)

        # Run the pipeline
        p   = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)

        (output, _) = p.communicate()
        exit_code   = p.wait()

        if exit_code != 0:
           #print("[ERROR] Problems running pipeline: {}".format(output.decode("UTF-8")))
           print(output.decode("UTF-8"))
           sys.exit(1)

        sys.exit(0)
